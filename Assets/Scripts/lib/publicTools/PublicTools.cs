//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18444
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using xy3d.tstd.lib.superTween;


namespace xy3d.tstd.lib.publicTools
{
	public class PublicTools
	{
		public static readonly string NORMAL_TAG_NAME = "Untagged";

		public static void ClearTag(GameObject _obj){
			
			_obj.tag = NORMAL_TAG_NAME;
			
			for(int i = 0 ; i < _obj.transform.childCount ; i++){
				
				ClearTag(_obj.transform.GetChild(i).gameObject);
			}
		}
		
		public static void SetTag(GameObject _obj,string _tag){
			
			_obj.tag = _tag;
			
			for(int i = 0 ; i < _obj.transform.childCount ; i++){
				
				SetTag(_obj.transform.GetChild(i).gameObject,_tag);
			}
		}

		public static GameObject FindChild(GameObject _obj,string _name){

			return FindChild(_obj,_name,0);
		}

		public static GameObject FindChildForce(GameObject _obj,string _name){
			
			if (_obj.name == _name) 
			{
				return _obj;
			}
			else 
			{
				for (int i = 0; i < _obj.transform.childCount; i++)
				{
					GameObject tmpObj = FindChildForce(_obj.transform.GetChild(i).gameObject, _name);
					
					if (tmpObj != null)
					{
						return tmpObj;
					}
				}
				
				return null;
			}
		}

		private static GameObject FindChild(GameObject _obj,string _name,int _index){

			if (_obj.name == _name) 
            {
				return _obj;
			}
            else 
            {
                _index++;
				
				for (int i = 0; i < _obj.transform.childCount; i++)
                {
                    GameObject tmpObj = FindChild(_obj.transform.GetChild(i).gameObject, _name, _index);

                    if (tmpObj != null)
                    {
                        return tmpObj;
                    }
				}

                if (_index == 1)
                {
                    throw new ArgumentOutOfRangeException("【PublicTools】----" + "找不到名字为" + _name + "的GameObject");
                }
                else{
                    
                    return null;
				}
			}
		}

		public static void AddChild(GameObject _parent, GameObject _child, string _jointName){

			if (!string.IsNullOrEmpty(_jointName)) {

				GameObject joint = FindChild(_parent,_jointName).gameObject;
				
				if (joint != null) {

					_child.transform.SetParent(joint.transform,false);

				}else{

					_child.transform.SetParent(_parent.transform,false);
				}

			} else {

				_child.transform.SetParent(_parent.transform,false);
			}
		}

		public static void SetLayer(GameObject _go, int _layer){

			_go.layer = _layer;
				
			for (int i = 0; i < _go.transform.childCount; i++) {
				
				SetLayer(_go.transform.GetChild(i).gameObject,_layer);
			}
		}

		public static void SetGameObjectVisible(GameObject _go,bool _visible){

			Renderer[] renderers = _go.GetComponentsInChildren<Renderer> ();

			for(int i = 0 ; i < renderers.Length ; i++){

				renderers[i].enabled = _visible;
			}
		}

		public static void StopParticle(GameObject _go){

			ParticleSystem[] systems = _go.GetComponentsInChildren<ParticleSystem> ();

			foreach (ParticleSystem system in systems) {

				system.Stop ();
			}
		}

		public static void PlayParticle(GameObject _go){
			
			ParticleSystem[] systems = _go.GetComponentsInChildren<ParticleSystem> ();
			
			foreach (ParticleSystem system in systems) {
				
				system.Play();
			}
		}

		public static byte[] StringToBytes(string str)
		{
			byte[] bytes = new byte[str.Length * sizeof(char)];
			System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
			return bytes;
		}
		
		public static string BytesToString(byte[] bytes)
		{
			char[] chars = new char[bytes.Length / sizeof(char)];
			System.Buffer.BlockCopy(bytes, 0, chars, 0, bytes.Length);
			return new string(chars);
		}

		public static string XmlFix(string _str){

			int index = _str.IndexOf("<");

			if(index == -1){

				return "";

			}else{

				return _str.Substring(index,_str.Length - index);
			}
		}

		public static Vector3 WorldPositionToCanvasPosition(Camera _worldCamera,RectTransform _canvasRect,Vector3 _worldPosition){

			Vector3 screenPos = _worldCamera.WorldToViewportPoint(_worldPosition);
			
			return new Vector3((screenPos.x * _canvasRect.sizeDelta.x) - (_canvasRect.sizeDelta.x * 0.5f),(screenPos.y * _canvasRect.sizeDelta.y) - (_canvasRect.sizeDelta.y * 0.5f),screenPos.z);
		}

		public static Vector3 MousePositionToCanvasPosition(Canvas _canvas,Vector3 _mousePosition){

			Vector3 screenPos = _canvas.worldCamera.ScreenToViewportPoint(_mousePosition);

			RectTransform canvasRect = _canvas.transform as RectTransform;

			return new Vector3((screenPos.x * canvasRect.sizeDelta.x) - (canvasRect.sizeDelta.x * 0.5f),(screenPos.y * canvasRect.sizeDelta.y) - (canvasRect.sizeDelta.y * 0.5f),screenPos.z);
		}

		//场景被卸载时，如果场景上有GameObject从来没有active过，那GameObject所引用的贴图就会残留在内存里了  这个方法就是确保场景上所有GameObject都曾经被active过
		public static void UnloadAllSceneGameObjects(GameObject _go){
			
			if(!_go.activeSelf){
				
				_go.SetActive(true);
				
				_go.SetActive(false);
			}
			
			for(int i = 0 ; i < _go.transform.childCount ; i++){
				
				UnloadAllSceneGameObjects(_go.transform.GetChild(i).gameObject);
			}
		}

		public static UInt16 ReverseBytes(UInt16 value)
		{
			return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
		}
		
		public static Int16 ReverseBytes(Int16 value)
		{
			return (Int16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
		}
		
		public static UInt32 ReverseBytes(UInt32 value)
		{
			return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |
				(value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
		}
		
		public static Int32 ReverseBytes(Int32 value)
		{
			return (Int32)((value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |
			               (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24);
		}
		
		public static UInt64 ReverseBytes(UInt64 value)
		{
			return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |
				(value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |
					(value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |
					(value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
		}

		public static void FlipParticleMeshWithAxisX(GameObject _go,float _zPos){

			ParticleSystemRenderer[] particleRenders = _go.GetComponentsInChildren<ParticleSystemRenderer>();
			
			for(int i = 0 ; i < particleRenders.Length ; i++){

				ParticleSystemRenderer particleRender = particleRenders[i];
				
				Material mat = particleRender.material;
				
				if(mat != null && particleRender.renderMode == ParticleSystemRenderMode.Mesh){
					
					mat.SetFloat("_Flip",-1);
				}
			}

			FlipGameObjectWithAxisX(_go.transform,_zPos);
		}

		private static void FlipGameObjectWithAxisX(Transform _trans,float _zPos){

			Vector3 position = new Vector3(_trans.position.x,_trans.position.y,_zPos * 2 - _trans.position.z);
			
			Vector3 up = _trans.up;
			
			Vector3 upFix = new Vector3(up.x,up.y,-up.z);
			
			Vector3 forward = _trans.position + _trans.forward;
			
			Vector3 forwardFix = new Vector3(forward.x,forward.y,_zPos * 2 - forward.z);

			_trans.position = position;
			
			_trans.LookAt(forwardFix,upFix);

			for(int i = 0 ; i < _trans.childCount ; i++){

				FlipGameObjectWithAxisX(_trans.GetChild(i),_zPos);
			}
		}

		public static void FlashOut(GameObject _go,float _time,int _times,Action _callBack){

			Renderer[] renders = _go.GetComponentsInChildren<Renderer>();
			
			float oneTime = _time / _times;
			
			Action<float> toDel = delegate(float obj) {
				
				int index = (int)(obj / oneTime);
				
				float fix = (obj - index * oneTime) / oneTime;
				
				if(fix > (float)index / _times){
					
					for(int i = 0 ; i < renders.Length ; i++){

						renders[i].enabled = true;
					}
					
				}else{
					
					for(int i = 0 ; i < renders.Length ; i++){
						
						renders[i].enabled = false;
					}
				}
			};
			
			Action endDel = delegate() {
				
				for(int i = 0 ; i < renders.Length ; i++){
					
					renders[i].enabled = false;
				}
				
				if(_callBack != null){
					
					_callBack();
				}
			};
			
			SuperTween.Instance.To(0,_time,_time,toDel,endDel);
		}
		
		public static void FlashIn(GameObject _go,float _time,int _times,Action _callBack){
			
			Renderer[] renders = _go.GetComponentsInChildren<Renderer>();

			for(int i = 0 ; i < renders.Length ; i++){
				
				renders[i].enabled = false;
			}
			
			float oneTime = _time / _times;
			
			Action<float> toDel = delegate(float obj) {
				
				int index = (int)(obj / oneTime);
				
				float fix = (obj - index * oneTime) / oneTime;
				
				if(fix < (float)index / _times){
					
					for(int i = 0 ; i < renders.Length ; i++){
						
						renders[i].enabled = true;
					}
					
				}else{
					
					for(int i = 0 ; i < renders.Length ; i++){
						
						renders[i].enabled = false;
					}
				}
			};
			
			Action endDel = delegate() {
				
				for(int i = 0 ; i < renders.Length ; i++){
					
					renders[i].enabled = true;
				}
				
				if(_callBack != null){
					
					_callBack();
				}
			};
			
			SuperTween.Instance.To(0,_time,_time,toDel,endDel);
		}

		public static Mesh CombineMeshs(GameObject[] _gos){
			
			int num = _gos.Length;
			
			Mesh mesh = new Mesh();
			
			CombineInstance[] cis = new CombineInstance[num];
			
			for(int i = 0 ; i < num ; i++){

				GameObject go = _gos[i];
				
				MeshFilter mf = go.GetComponent<MeshFilter>();
				
				Mesh tmpMesh = mf.mesh;
				
				Vector4[] ts = new Vector4[tmpMesh.vertexCount];
				
				for(int m = 0 ; m < tmpMesh.vertexCount ; m++){
					
					ts[m] = new Vector4(i,i,i,i);
				}
				
				tmpMesh.tangents = ts;
				
				cis[i].mesh = tmpMesh;

//				cis[i].transform = _gos[i].transform.localToWorldMatrix;

				cis[i].transform = Matrix4x4.TRS(go.transform.localPosition,go.transform.localRotation,go.transform.localScale);
				
				SetGameObjectVisible(go,false);
			}
			
			mesh.CombineMeshes(cis);
			
			return mesh;
		}

		public static int[] SplitInt(int _data,int _num,float _range){

			int[] result = new int[_num];

			int numRec = _num;

			for(int i = 0 ; i < numRec - 1 ; i++){

				int data = (int)((float)_data / _num * (1 + (UnityEngine.Random.value * 2 - 1) * _range));

				result[i] = data;

				_data -= data;

				_num--;
			}

			result[numRec - 1] = _data;

			return result;
		}

		public static float[] SplitFloat(float _data,int _num,float _range){
			
			float[] result = new float[_num];
			
			int numRec = _num;
			
			for(int i = 0 ; i < numRec - 1 ; i++){
				
				float data = (float)_data / _num * (1 + (UnityEngine.Random.value * 2 - 1) * _range);
				
				result[i] = data;
				
				_data -= data;
				
				_num--;
			}
			
			result[numRec - 1] = _data;
			
			return result;
		}
	}
}

